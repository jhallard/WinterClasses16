John Allard
1437547
Feb 4th 2016

CMPS 112 Homework #4

Read "Input and Output" and "Functionally Solving Problems" Chapters of the Haskell book
and write about it.

The first section we read about was regarding input and output and how that is handled in Hakell. The problem is introduced as Haskell is a pure language, so how do we perform operations that allow us to change state like reading/writing from a terminal? Haskell solved this by supplying the IO monad, which serves as an divider between the 'pure' and 'unpure' parts of our code allowing them to interact in well defined ways that doesn't allow the unpure code to poison the well, so to speak. We start by learning about the simple putStrLn and putStr function to write to the terminal. These functions, like others in the IO monad, take in a String (or other type) and return an IO action. This IO action can have data associated with it, like if we are reading input, but for the two aforementioned functions no data is bound to the returned action. IO actions describe a process to perform input or output in Haskell. We then move onto the main function and how it allows us to define IO actions inside of it. We then move onto convenient helper functions that let us map IO functions over lists, mapM and mapM_ for example. Even though at first it seemed like it was going to be quite difficult to do IO in a functional language, this section showed that it's actally quite convenient once you wrap your head around the boundaries that Haskell has put up for our own benefit.

The next section we read was about how to think about solving problems in a functional manner. This is always a large stepping stone for programmers who start with procedural languages then move onto something like Haskell, their minds (aka my mind) has trouble adjusting to the new paradigm and instead tries to force old ideas from C/Java into Haskell, which can only result in non-valid or plain hideous haskell code. We start in this section by thinking about reverse polish notation and it's various benefits over infix notation. We think about how we go about using the tools we already know (namely fold and map) to take in s string in valid RPN and parse it into the desired result. A quick example demonstraits how to do this with a recursive function using a simple where clause based on the operator encountered. We then move onto another problem regarding routing, namely how to get from Heathrow Airport to London as fast as we can. We start by building a graph-like structure with nodes to hold the data that represents the rode-network between the two points. We make clever use of the maybe keyword to allow for points that might have a single or double intersection. We then associate integers with each road to represent its appropriate cost. We work our way to an algorithm that computes the lowest cost between the two points in a beautiful, concise, and functional manner. 
